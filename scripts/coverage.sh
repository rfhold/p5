#!/bin/bash
# Run tests with coverage and generate reports
#
# Usage: ./scripts/coverage.sh [options]
#   -html     Open HTML report in browser
#   -func     Show per-function breakdown (default: summary only)
#   -v        Verbose test output
#   -md       Generate markdown report (COVERAGE.md)

set -e

# Parse arguments
OPEN_HTML=false
SHOW_FUNC=false
VERBOSE=""
GEN_MARKDOWN=false

for arg in "$@"; do
    case "$arg" in
        -html) OPEN_HTML=true ;;
        -func) SHOW_FUNC=true ;;
        -v) VERBOSE="-v" ;;
        -md) GEN_MARKDOWN=true ;;
    esac
done

# Patterns to exclude from coverage (pipe-separated regex)
EXCLUDE_PATTERNS="fakes\.go|_mock\.go|_test\.go|/proto/|/testdata/"

# Find packages, excluding proto, test/example programs, and testdata directories
PACKAGES=$(go list ./... | grep -v -E '/proto$|/testdata$|^github.com/rfhold/p5/test/|^github.com/rfhold/p5/programs/')

echo "Running tests with coverage (including integration tests)..."
go test $VERBOSE -tags=integration -covermode=count -coverprofile=coverage.out.tmp $PACKAGES

# Filter out excluded files
if grep -v -E "$EXCLUDE_PATTERNS" coverage.out.tmp > coverage.out 2>/dev/null; then
    rm coverage.out.tmp
else
    # If grep found nothing to exclude, use the original
    mv coverage.out.tmp coverage.out
fi

echo ""
echo "=== Coverage Summary ==="

if [ "$SHOW_FUNC" = true ]; then
    go tool cover -func=coverage.out
    echo ""
fi

# Extract and display total coverage
TOTAL=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
echo "Total Coverage: $TOTAL"

# Open HTML report if requested
if [ "$OPEN_HTML" = true ]; then
    echo ""
    echo "Opening HTML report..."
    go tool cover -html=coverage.out
fi

# Generate markdown report if requested
if [ "$GEN_MARKDOWN" = true ]; then
    echo ""
    echo "Generating markdown report..."

    # Get git info
    GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
    GIT_COMMIT_FULL=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    GIT_DIRTY=""
    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
        GIT_DIRTY=" (dirty)"
    fi
    GIT_DATE=$(git log -1 --format=%ci 2>/dev/null || echo "unknown")
    REPORT_DATE=$(date "+%Y-%m-%d %H:%M:%S")

    # Get module name for stripping from paths
    MODULE_NAME=$(go list -m 2>/dev/null || echo "")

    MD_FILE="COVERAGE.md"

    # Start markdown file
    cat > "$MD_FILE" << EOF
# Test Coverage Report

> **Generated:** ${REPORT_DATE}
> **Commit:** \`${GIT_COMMIT}\`${GIT_DIRTY}
> **Commit Date:** ${GIT_DATE}

## Summary

**Total Coverage: ${TOTAL}**

EOF

    # Generate package summary table
    echo "| Package | Coverage |" >> "$MD_FILE"
    echo "|---------|----------|" >> "$MD_FILE"

    # Get coverage per package (last function entry per file gives the file coverage)
    go tool cover -func=coverage.out | \
        grep -v "^total:" | \
        awk -F: '{print $1}' | \
        sort -u | \
        while read filepath; do
            # Extract package path from file path
            pkg_path=$(dirname "$filepath")
            echo "$pkg_path"
        done | \
        sort -u | \
        while read pkg; do
            # Calculate package coverage by averaging file coverages
            pkg_coverage=$(go tool cover -func=coverage.out | \
                grep "^${pkg}/" | \
                grep -v "^total:" | \
                awk '{print $NF}' | \
                sed 's/%//' | \
                awk '{sum+=$1; count++} END {if(count>0) printf "%.1f%%", sum/count; else print "N/A"}')

            # Strip module name for cleaner display
            display_pkg="${pkg#${MODULE_NAME}/}"
            echo "| \`${display_pkg}\` | ${pkg_coverage} |" >> "$MD_FILE"
        done

    # Add detailed breakdown
    cat >> "$MD_FILE" << EOF

## Detailed Coverage by File

<details>
<summary>Click to expand file-level coverage</summary>

| File | Function | Coverage |
|------|----------|----------|
EOF

    # Generate per-function coverage table
    go tool cover -func=coverage.out | \
        grep -v "^total:" | \
        while IFS= read -r line; do
            # Parse the line: file:line: function coverage%
            filepath=$(echo "$line" | awk -F: '{print $1}')
            func_name=$(echo "$line" | awk '{print $(NF-1)}')
            coverage=$(echo "$line" | awk '{print $NF}')

            # Strip module name for cleaner display
            display_path="${filepath#${MODULE_NAME}/}"

            echo "| \`${display_path}\` | \`${func_name}\` | ${coverage} |" >> "$MD_FILE"
        done

    cat >> "$MD_FILE" << EOF

</details>

---

<sub>Generated by \`./scripts/coverage.sh -md\` from commit [\`${GIT_COMMIT}\`](../../commit/${GIT_COMMIT_FULL})${GIT_DIRTY}</sub>
EOF

    echo "Markdown report written to $MD_FILE"

    # Print abridged summary to console
    echo ""
    echo "=== Abridged Summary ==="
    echo "Commit: ${GIT_COMMIT}${GIT_DIRTY}"
    echo "Total Coverage: ${TOTAL}"
    echo ""
    echo "Top packages by coverage:"
    go tool cover -func=coverage.out | \
        grep -v "^total:" | \
        awk -F: '{print $1}' | \
        sort -u | \
        while read filepath; do
            dirname "$filepath"
        done | \
        sort -u | \
        head -10 | \
        while read pkg; do
            pkg_coverage=$(go tool cover -func=coverage.out | \
                grep "^${pkg}/" | \
                awk '{print $NF}' | \
                sed 's/%//' | \
                awk '{sum+=$1; count++} END {if(count>0) printf "%.1f%%", sum/count; else print "N/A"}')
            display_pkg="${pkg#${MODULE_NAME}/}"
            printf "  %-40s %s\n" "$display_pkg" "$pkg_coverage"
        done
fi
